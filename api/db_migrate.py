from __future__ import annotations

import os
from pathlib import Path

from loguru import logger

from bot.config import DB_TABLE_PREFIX
from bot.db.connection import get_db_context


def _is_truthy(value: str | None, default: bool = True) -> bool:
    if value is None:
        return default
    return value.strip().lower() not in {"0", "false", "no", "off"}


def _split_sql_statements(sql: str) -> list[str]:
    statements: list[str] = []
    buf: list[str] = []

    in_single = False
    in_double = False
    in_backtick = False
    in_line_comment = False
    in_block_comment = False

    def is_escaped(pos: int) -> bool:
        # Count backslashes just before this position
        bs = 0
        j = pos - 1
        while j >= 0 and sql[j] == "\\":
            bs += 1
            j -= 1
        return (bs % 2) == 1

    i = 0
    n = len(sql)
    while i < n:
        ch = sql[i]
        nxt = sql[i + 1] if i + 1 < n else ""

        if in_line_comment:
            if ch == "\n":
                in_line_comment = False
            i += 1
            continue

        if in_block_comment:
            if ch == "*" and nxt == "/":
                in_block_comment = False
                i += 2
                continue
            i += 1
            continue

        if not (in_single or in_double or in_backtick):
            if ch == "-" and nxt == "-":
                in_line_comment = True
                i += 2
                continue
            if ch == "#":
                in_line_comment = True
                i += 1
                continue
            if ch == "/" and nxt == "*":
                in_block_comment = True
                i += 2
                continue

        if ch == "'" and not (in_double or in_backtick) and not is_escaped(i):
            in_single = not in_single
        elif ch == '"' and not (in_single or in_backtick) and not is_escaped(i):
            in_double = not in_double
        elif ch == "`" and not (in_single or in_double):
            in_backtick = not in_backtick

        if ch == ";" and not (in_single or in_double or in_backtick):
            stmt = "".join(buf).strip()
            if stmt:
                statements.append(stmt)
            buf = []
            i += 1
            continue

        buf.append(ch)
        i += 1

    tail = "".join(buf).strip()
    if tail:
        statements.append(tail)

    return statements


def _apply_schema_file(sql_path: Path) -> None:
    sql_text = sql_path.read_text(encoding="utf-8", errors="replace")
    statements = _split_sql_statements(sql_text)

    non_views: list[str] = []
    views: list[str] = []

    for stmt in statements:
        head = stmt.lstrip().split(None, 4)[:4]
        head_str = " ".join(head).lower()
        if head_str.startswith("create database") or head_str.startswith("use "):
            continue
        if head_str.startswith("create or replace view") or head_str.startswith("create view"):
            views.append(stmt)
        else:
            non_views.append(stmt)

    with get_db_context() as conn:
        cursor = conn.cursor()

        # Pass 1: tables/indexes/inserts (avoid failing early on views that depend on new columns).
        for stmt in non_views:
            try:
                cursor.execute(stmt)
            except Exception as e:
                # Make schema execution idempotent enough for startup runs.
                msg = str(e).lower()
                ignorable = (
                    "duplicate key name" in msg
                    or "duplicate column name" in msg
                    or "already exists" in msg
                )
                if ignorable:
                    continue
                raise

        # Pass 2: views (best-effort; schema drift can break them temporarily).
        for stmt in views:
            try:
                cursor.execute(stmt)
            except Exception as e:
                msg = str(e).lower()
                # Common drift: columns missing at the time of view creation.
                ignorable = (
                    "unknown column" in msg
                    or "doesn't exist" in msg
                    or "table" in msg and "doesn't exist" in msg
                )
                if ignorable:
                    logger.warning(f"[db] View skipped (schema drift): {str(e)[:180]}")
                    continue
                raise


def _column_info(table_name: str, column_name: str) -> dict | None:
    with get_db_context() as conn:
        cursor = conn.cursor(dictionary=True)
        cursor.execute(
            """
            SELECT column_name, data_type, character_maximum_length
            FROM information_schema.columns
            WHERE table_schema = DATABASE()
              AND table_name = %s
              AND column_name = %s
            """,
            (table_name, column_name),
        )
        return cursor.fetchone()


def _table_exists(table_name: str) -> bool:
    with get_db_context() as conn:
        cursor = conn.cursor()
        cursor.execute(
            """
            SELECT 1
            FROM information_schema.tables
            WHERE table_schema = DATABASE()
              AND table_name = %s
            LIMIT 1
            """,
            (table_name,),
        )
        return cursor.fetchone() is not None


def _ensure_dashboard_sessions_migrations() -> None:
    table = f"{DB_TABLE_PREFIX}dashboard_sessions"
    if not _table_exists(table):
        return

    # Add is_revoked if missing.
    if _column_info(table, "is_revoked") is None:
        with get_db_context() as conn:
            cursor = conn.cursor()
            cursor.execute(
                f"ALTER TABLE {table} ADD COLUMN is_revoked TINYINT(1) DEFAULT 0"
            )

    # Add guild_ids_json if missing.
    if _column_info(table, "guild_ids_json") is None:
        with get_db_context() as conn:
            cursor = conn.cursor()
            cursor.execute(
                f"ALTER TABLE {table} "
                f"ADD COLUMN guild_ids_json JSON NULL "
                f"COMMENT 'Liste des guild_ids autorises (owner/admin) au login'"
            )

    # Ensure jwt_token is TEXT (older init.sql used VARCHAR(500)).
    info = _column_info(table, "jwt_token")
    if info and (info.get("data_type") or "").lower() in {"varchar", "char"}:
        with get_db_context() as conn:
            cursor = conn.cursor()
            cursor.execute(f"ALTER TABLE {table} MODIFY COLUMN jwt_token TEXT")

    # Ensure access_token can hold Discord access tokens comfortably.
    info = _column_info(table, "access_token")
    max_len = info.get("character_maximum_length") if info else None
    if info and (info.get("data_type") or "").lower() in {"varchar", "char"} and (max_len or 0) < 500:
        with get_db_context() as conn:
            cursor = conn.cursor()
            cursor.execute(f"ALTER TABLE {table} MODIFY COLUMN access_token VARCHAR(500)")


def _ensure_bot_status_migrations() -> None:
    """Ajoute les nouvelles colonnes a vai_bot_status si elles manquent."""
    table = f"{DB_TABLE_PREFIX}bot_status"
    if not _table_exists(table):
        return

    new_columns = {
        "channel_count": "INT DEFAULT 0 COMMENT 'Nombre total de channels accessibles'",
        "latency_ms":    "FLOAT DEFAULT 0 COMMENT 'Latence WebSocket Discord en ms'",
        "shard_count":   "INT DEFAULT 1 COMMENT 'Nombre de shards actifs'",
        "started_at":    "TIMESTAMP NULL COMMENT 'Heure de demarrage du bot'",
    }

    for col_name, col_def in new_columns.items():
        if _column_info(table, col_name) is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(f"ALTER TABLE {table} ADD COLUMN {col_name} {col_def}")
                    logger.info(f"[db] Colonne {col_name} ajoutee a {table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {table}.{col_name}: {e}")


def _ensure_ticket_migrations() -> None:
    """Ajoute les colonnes necessaires pour update embed + stockage complet messages."""
    tickets_table = f"{DB_TABLE_PREFIX}tickets"
    if _table_exists(tickets_table):
        # Snapshot username at ticket creation (used by dashboard and bot).
        if _column_info(tickets_table, "user_username") is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(
                        f"ALTER TABLE {tickets_table} "
                        f"ADD COLUMN user_username VARCHAR(100) NULL "
                        f"COMMENT 'Snapshot username au moment de louverture'"
                    )
                    logger.info(f"[db] Colonne user_username ajoutee a {tickets_table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {tickets_table}.user_username: {e}")

        # Assigned staff name (dashboard display)
        if _column_info(tickets_table, "assigned_staff_name") is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(
                        f"ALTER TABLE {tickets_table} "
                        f"ADD COLUMN assigned_staff_name VARCHAR(100) NULL"
                    )
                    logger.info(f"[db] Colonne assigned_staff_name ajoutee a {tickets_table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {tickets_table}.assigned_staff_name: {e}")

        if _column_info(tickets_table, "assigned_staff_id") is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(
                        f"ALTER TABLE {tickets_table} "
                        f"ADD COLUMN assigned_staff_id BIGINT NULL"
                    )
                    logger.info(f"[db] Colonne assigned_staff_id ajoutee a {tickets_table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {tickets_table}.assigned_staff_id: {e}")

        if _column_info(tickets_table, "initial_message_id") is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(
                        f"ALTER TABLE {tickets_table} "
                        f"ADD COLUMN initial_message_id BIGINT NULL "
                        f"COMMENT 'Message embed initial du ticket (pour mise a jour langue)'"
                    )
                    logger.info(f"[db] Colonne initial_message_id ajoutee a {tickets_table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {tickets_table}.initial_message_id: {e}")

    msgs_table = f"{DB_TABLE_PREFIX}ticket_messages"
    if _table_exists(msgs_table):
        if _column_info(msgs_table, "author_username") is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(
                        f"ALTER TABLE {msgs_table} "
                        f"ADD COLUMN author_username VARCHAR(100) NULL"
                    )
                    logger.info(f"[db] Colonne author_username ajoutee a {msgs_table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {msgs_table}.author_username: {e}")

        if _column_info(msgs_table, "discord_message_id") is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(
                        f"ALTER TABLE {msgs_table} "
                        f"ADD COLUMN discord_message_id BIGINT NULL "
                        f"COMMENT 'Discord Message ID'"
                    )
                    logger.info(f"[db] Colonne discord_message_id ajoutee a {msgs_table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {msgs_table}.discord_message_id: {e}")

        if _column_info(msgs_table, "attachments_json") is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(
                        f"ALTER TABLE {msgs_table} "
                        f"ADD COLUMN attachments_json JSON NULL "
                        f"COMMENT 'Liste d attachments (urls, filenames, etc.)'"
                    )
                    logger.info(f"[db] Colonne attachments_json ajoutee a {msgs_table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {msgs_table}.attachments_json: {e}")


def _ensure_guild_v04_migrations() -> None:
    """Ajoute les colonnes v0.4 a vai_guilds (ticket custom + AI prompt)."""
    table = f"{DB_TABLE_PREFIX}guilds"
    if not _table_exists(table):
        return

    new_columns = {
        "ticket_open_channel_id":     "BIGINT NULL COMMENT 'Channel bouton/selecteur ouverture ticket'",
        "ticket_open_message":        "TEXT NULL COMMENT 'Message avec bouton/selecteur'",
        "ticket_button_label":        "VARCHAR(100) DEFAULT 'Ouvrir un ticket'",
        "ticket_button_style":        "VARCHAR(20) DEFAULT 'primary'",
        "ticket_button_emoji":        "VARCHAR(50) NULL",
        "ticket_welcome_message":     "TEXT NULL COMMENT 'Message bienvenue personnalise'",
        "ticket_welcome_color":       "VARCHAR(10) DEFAULT 'blue'",
        "ticket_selector_enabled":    "TINYINT(1) DEFAULT 0",
        "ticket_selector_placeholder": "VARCHAR(200) DEFAULT 'Selectionnez le type de ticket'",
        "ticket_selector_options":    "JSON NULL",
        "ticket_mention_staff":       "TINYINT(1) DEFAULT 1",
        "ticket_close_on_leave":      "TINYINT(1) DEFAULT 0",
        "ticket_max_open":            "INT DEFAULT 1",
        "staff_languages_json":       "JSON NULL COMMENT 'Langues staff [{user_id,username,language}]'",
        "ai_custom_prompt":           "TEXT NULL COMMENT 'Prompt IA personnalise'",
        "ai_prompt_enabled":          "TINYINT(1) DEFAULT 0",
        # Deploy queue / persistence
        "ticket_open_message_id":      "BIGINT NULL COMMENT 'Message ID du message ouverture tickets (pour edit)'",
        "ticket_open_needs_deploy":    "TINYINT(1) DEFAULT 0 COMMENT '1 = bot doit (re)deployer le message ouverture'",
        "ticket_open_last_deploy_error": "TEXT NULL COMMENT 'Derniere erreur de deploiement (debug)'",
        "ticket_open_delete_requested":  "TINYINT(1) DEFAULT 0 COMMENT '1 = bot doit supprimer le message ouverture'",
    }

    for col_name, col_def in new_columns.items():
        if _column_info(table, col_name) is None:
            with get_db_context() as conn:
                cursor = conn.cursor()
                try:
                    cursor.execute(f"ALTER TABLE {table} ADD COLUMN {col_name} {col_def}")
                    logger.info(f"[db] Colonne {col_name} ajoutee a {table}")
                except Exception as e:
                    if "duplicate column" not in str(e).lower():
                        logger.warning(f"[db] ALTER {table}.{col_name}: {e}")


def _ensure_knowledge_base_migrations() -> None:
    """Ajoute les colonnes KB manquantes (schema drift)."""
    table = f"{DB_TABLE_PREFIX}knowledge_base"
    if not _table_exists(table):
        return

    if _column_info(table, "is_active") is None:
        with get_db_context() as conn:
            cursor = conn.cursor()
            try:
                cursor.execute(
                    f"ALTER TABLE {table} "
                    f"ADD COLUMN is_active TINYINT(1) DEFAULT 1"
                )
                logger.info(f"[db] Colonne is_active ajoutee a {table}")
            except Exception as e:
                if "duplicate column" not in str(e).lower():
                    logger.warning(f"[db] ALTER {table}.is_active: {e}")


def ensure_database_schema() -> None:
    """
    Creates/migrates the MySQL schema at API startup using the `database/` folder.

    This is meant to fix common drift issues (ex: missing vai_dashboard_sessions.is_revoked),
    and to auto-create tables/views in fresh environments.
    """
    if not _is_truthy(os.getenv("AUTO_DB_MIGRATE"), default=True):
        logger.info("[db] AUTO_DB_MIGRATE=0 -> skip migrations")
        return

    root = Path(__file__).resolve().parents[1]
    schema_sql = root / "database" / "schema.sql"

    if not schema_sql.exists():
        logger.warning(f"[db] schema.sql introuvable: {schema_sql}")
        return

    logger.info(f"[db] Migration schema depuis {schema_sql}")
    # 1) Apply non-view statements first (tables/indexes/inserts).
    # 2) Apply targeted ALTERs (schema drift fixes).
    # 3) Re-apply views (so they can reference the new columns).
    _apply_schema_file(schema_sql)

    # Targeted ALTERs for already-existing tables.
    _ensure_dashboard_sessions_migrations()
    _ensure_bot_status_migrations()
    _ensure_ticket_migrations()
    _ensure_knowledge_base_migrations()
    _ensure_guild_v04_migrations()

    # Re-apply views after ALTERs (best-effort).
    try:
        _apply_schema_file(schema_sql)
    except Exception as e:
        # Don't block startup only because of view creation issues in older schemas.
        logger.warning(f"[db] Second pass schema apply failed (views?): {str(e)[:180]}")

    logger.info("[db] Migration OK")
